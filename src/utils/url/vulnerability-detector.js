class SecurityVulnerabilityDetector {
  constructor(extractedData, options = {}) {
    this.data = extractedData || {};
    this.html = this.data.html || "";
    this.responses = this.data.responses || [];
    this.requests = this.data.networkRequests || [];
    this.cookies = this.data.cookies || [];
    this.jsFiles = this.data.jsFiles || [];
    this.forms = this.data.forms || [];
    this.links = this.data.links || [];
    this.report = {
      url: this.data.url || null,
      timestamp: new Date().toISOString(),
      categories: {},
      recommendations: [],
    };
  }

  detectAll() {
    this.report.categories.transportAndMixedContent =
      this.detectTransportAndMixedContent();
    this.report.categories.securityHeaders = this.detectSecurityHeaders();
    this.report.categories.performance = this.detectPerformance();
    this.report.categories.formsAndInputs = this.detectFormsAndInputs();
    this.report.categories.dangerousScripts = this.detectDangerousScripts();
    this.report.categories.exposedSecrets = this.detectExposedSecrets();
    this.report.categories.cookies = this.detectCookies();
    this.report.categories.openRedirects = this.detectOpenRedirectParameters();
    this.report.categories.hiddenIframes = this.detectHiddenIframes();
    this.report.categories.fingerprinting = this.detectFingerprinting();
    this.report.categories.tracking = this.detectTracking();
    this.report.categories.phishingIndicators = this.detectPhishingIndicators();

    this.generateRecommendations();
    return this.report;
  }

  // ---------- DETECTORS ----------
  detectTransportAndMixedContent() {
    const url = this.data.url || "";
    const isHTTPS = url.startsWith("https://");
    const insecureResources = (this.requests || [])
      .filter(
        (req) =>
          req.url &&
          req.url.startsWith("http://") &&
          req.resourceType !== "document",
      )
      .map((req) => ({ url: req.url, type: req.resourceType || "unknown" }));

    return {
      isHTTPS,
      mixedContent: {
        found: insecureResources.length > 0,
        count: insecureResources.length,
        details: insecureResources,
      },
    };
  }

  detectSecurityHeaders() {
    const headers = this._mainHeadersLower();
    const must = [
      "content-security-policy",
      "x-frame-options",
      "x-xss-protection",
      "x-content-type-options",
      "strict-transport-security",
      "referrer-policy",
    ];
    const present = {};
    const missing = [];
    must.forEach((h) => {
      if (headers[h]) present[h] = headers[h];
      else missing.push(h);
    });
    return { present, missing, totalMissing: missing.length };
  }

  detectPerformance() {
    const h = this._mainHeadersLower();
    return [
      { name: "Compression", value: h["content-encoding"] || "none" },
      { name: "Caching", value: h["cache-control"] || h["expires"] || "none" },
    ];
  }

  detectFormsAndInputs() {
    const forms = this.forms || [];
    let insecureForms = 0,
      loginForms = 0,
      csrfProtected = 0;
    forms.forEach((form) => {
      const hasPassword = (form.inputs || []).some(
        (i) => (i.type || "").toLowerCase() === "password",
      );
      const hasUsername = (form.inputs || []).some(
        (i) => (i.type || "").toLowerCase() === "text",
      );
      if (hasPassword && hasUsername) loginForms++;
      if ((form.action || "").startsWith("http://")) insecureForms++;
      if (
        (form.inputs || []).some((i) =>
          (i.name || "").toLowerCase().includes("csrf"),
        )
      )
        csrfProtected++;
    });
    return {
      totalForms: forms.length,
      loginForms,
      insecureForms,
      csrfProtection: csrfProtected > 0 ? "Yes" : "No",
    };
  }

  detectDangerousScripts() {
    const issues = [];
    const patterns = [
      /eval\s*\(/gi,
      /document\.write\s*\(/gi,
      /innerHTML\s*=/gi,
    ];
    this.jsFiles.forEach((js) => {
      const content = js.content || js.inline || "";
      patterns.forEach((p) => {
        if (p.test(content))
          issues.push({ file: js.src || "inline", pattern: p.toString() });
      });
    });
    return { totalIssues: issues.length, issues };
  }

  detectExposedSecrets() {
    const patterns = [/api[_-]?key/i, /secret[_-]?key/i, /password/i, /token/i];
    const findings = [];
    this.jsFiles.forEach((js) => {
      const content = js.content || js.inline || "";
      patterns.forEach((p) => {
        if (p.test(content))
          findings.push({ file: js.src || "inline", match: p.toString() });
      });
    });
    return { count: findings.length, details: findings };
  }

  detectCookies() {
    const cookies = this.cookies || [];
    return cookies.map((c) => ({
      name: c.name,
      secure: !!c.secure,
      httpOnly: !!c.httpOnly,
      sameSite: c.sameSite || null,
    }));
  }

  detectOpenRedirectParameters() {
    const paramNames = ["redirect", "return", "url", "next"];
    const suspiciousLinks = (this.links || []).filter((link) => {
      try {
        const u = new URL(link.href);
        return paramNames.some((p) => u.searchParams.has(p));
      } catch {
        return false;
      }
    });
    return { linkCount: suspiciousLinks.length, links: suspiciousLinks };
  }

  detectHiddenIframes() {
    const iframes = this.html.match(/<iframe[^>]*>/gi) || [];
    const hidden = iframes.filter(
      (t) => t.includes("display:none") || /width\s*=\s*["']?0/.test(t),
    );
    return { totalIframes: iframes.length, hiddenCount: hidden.length };
  }

  detectFingerprinting() {
    const apis = [
      "canvas.getcontext",
      "webgl",
      "audiocontext",
      "navigator.useragent",
    ];
    const used = [];
    this.jsFiles.forEach((js) => {
      const content = (js.content || js.inline || "").toLowerCase();
      apis.forEach((api) => {
        if (content.includes(api)) used.push(api);
      });
    });
    return { used, score: used.length };
  }

  detectTracking() {
    const trackers = ["google-analytics.com", "facebook.com", "hotjar.com"];
    const found = this.requests.filter((r) =>
      trackers.some((d) => (r.url || "").includes(d)),
    );
    return { trackers: found.map((f) => f.url), count: found.length };
  }

  detectPhishingIndicators() {
    const text = this._textContent(this.html);
    const urgent = /urgent.{0,20}action/i.test(text);
    return {
      urgentLanguage: urgent,
      issues: urgent ? ["Urgent language detected"] : [],
    };
  }

  // ---------- RECOMMENDATIONS ----------
  generateRecommendations() {
    const rec = [];
    if (this.report.categories.securityHeaders.missing.length)
      rec.push(
        `Add missing headers: ${this.report.categories.securityHeaders.missing.join(", ")}`,
      );
    if (this.report.categories.formsAndInputs.insecureForms > 0)
      rec.push("Fix insecure form actions (use HTTPS).");
    this.report.recommendations = rec;
  }

  // ---------- HELPERS ----------
  _mainHeadersLower() {
    const main =
      this.responses.find((r) => r.url === this.data.url) || this.responses;
    const out = {};
    if (main && main.headers) {
      for (const [k, v] of Object.entries(main.headers))
        out[k.toLowerCase()] = v;
    }
    return out;
  }
  _textContent(html) {
    return (html || "")
      .replace(/<script[\s\S]*?<\/script>/gi, " ")
      .replace(/<style[\s\S]*?<\/style>/gi, " ")
      .replace(/<[^>]+>/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }
}

module.exports = SecurityVulnerabilityDetector;
